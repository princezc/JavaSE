强烈推荐《JVM虚拟机与高级特性》这本书多看几遍再看下面，这部分主要会贯穿很多知识点，主要是将知识点串联起来，有个大局观用的。具体细小的概念百度一清二楚。

## 为什么要了解运行时数据区

什么是运行时数据区？这个问题其实很简单，就是JVM运行时其内部管理的数据区域的划分。JAVA程序运行时需要依托一个运行平台来运行，也就是JVM虚拟机。只要有java程序运行，一定会启动JVM进程（不信你可以去运行个java程序然后打开任务管理器查看进程）。JVM是用来将class文件转换为可用的类，然后进行运行，简单来说，JVM是保证java程序与底层操作系统无关的关键。那么大家都知道，对于电脑来说，硬盘的容量往往比内存要大很多，但是硬盘的读写速度往往比内存要慢，所以电脑在运行程序时，都会将进程开在内存里，而硬盘则是负责存储一些持久化数据用。内存容量比较小，如果你开的很多个进程把内存甚至虚拟内存都吃完了，那这个时候电脑就奇卡无比了。jvm也是一个进程，它也会去占用内存，所以对其进程占用内存大小进行了解与讨论能有效地解决实际工作中遇到的一些OOM问题。这里对于进程与线程再啰嗦几句，在操作系统的概念中，进程与线程是一定要知道的。进程是一个应用的最小隔离空间。理论上，进程与进程之间是相互隔离的，而线程是CPU执行最小单位，一个进程中可以有多个线程，也就是说一个进程完成的工作可以分配给若干个线程同时或交替完成。而线程对于JAVA而言，在常见操作系统中它的线程是与实际CPU线程1:1的关系，java中的线程会经过用户态转换至核心态，而托付给操作系统的线程来做。有点扯远了哈。。

所以了解运行时数据区，最直观地，可以知道发生OOM时候一般会是哪几部分发生了问题，进而在实际写代码时可以考虑到内存管理的问题来杜绝很大一部分OOM的发生，而且了解其中的机制也可以编写出更有效率的代码。
    
## 运行时数据区是什么
![jvm运行时数据区.jpg]({{site.baseurl}}/jvm运行时数据区.jpg)
这个问题上面已经回答过了。但是有些人还是会把它与JMM搞混。JMM是java内存模型，它是jvm对于自身并发安全的最小保证，硬要说和运行时数据区有关系也可以说，但是运行时数据区更倾向于对于JVM内部数据区域的划分。

这个图片是我做笔记的时候画的，有点懒了不想再拿画图工具重画一遍了，顺便治好下你们的颈椎病哈哈。
运行时数据区的图片网上到处都是，随便百度就能百度到，不过我将几个概念全部汇总起来，看起来更清晰了点。

主要来说，分为两大块，一块是所有线程共享的区域，包含方法区，堆；另一块是线程独占的区域，包含VM栈，PC计数器，本地方法栈。

1.方法区：方法区主要存类信息（元数据），静态变量（static），包含有常量池。常量池会存一些常量，以及比如String常量池也是位于这里的。这部分在jdk8之前叫做permGem，jdk8后改名为meta space。个人认为永久代命名有点问题吧，毕竟垃圾回收也是会涉及到方法区这里的，metaSpace倒是把这块区域存什么说的一清二楚。此外metaSpace取消了之前permGem的大小限制，这部分区域大小变得可以扩展了。

2.堆：堆里主要存对象。几乎所有的对象都存放在堆里（编译器优化里有栈上替换这种操作，可以把部分对象优化至VM栈中）。堆也是垃圾回收器主要的操作区域。堆分为新生代与老年代，新生代中有eden：sfrom：sto=8:1:1,新生代:老年代=1:2或者1:1.5。这些大小比都是常用的设置，当然也可以自己去定义大小比。堆里主要存放的是对象，简单说下对象在JVM里是什么样的结构。

对象分为对象头，实例数据以及对齐填充。对象头内部又分为MarkWord（它是Synchronized中锁机制实现的关键）以及类型指针。如果这是个数组对象它还会包含数组长度（length，这也是为什么数组的长度是以一个单独的属性值展示的）。类型指针会指向方法区中该对象对应的类。

这么一个对象，在堆中是怎么存放的呢，可以想象成一个个小矩形放在一个大矩形那样。有两种方式，一种是指针碰撞（复制，标记-整理），另一种是空闲列表（标记-清除）。指针碰撞就是一个紧挨着一个整齐放好，空闲列表就是有一个列表来记录哪个地方有空，然后有空隙的地方去放对象。这两种方式都是依托于各自的垃圾回收机制而言的，正如方法后面括号内的对应的垃圾回收机制那样。垃圾回收机制一般有这么几种方式：找到要回收的直接清除（标记-清除），找到要回收的，清理完后把存活的排到一边（标记-整理），找到要回收的，把不用回收的放到另一半区域，把这半边区域清理了（复制）。标记清除这种方法所会造成很多的内存碎片，这也是会有空闲列表的原因。

堆采用了分代回收机制，新生代用一种垃圾回收算法，老年代用一种垃圾回收算法。而一般新生代用的是复制，因为新生代小对象多，标记清除会产生碎片太多，标记整理则需要太多次整理影响效率。所以新生代会有两个survivor。老年代一般可以用标记清除或者标记整理，因为对象的寿命会趋向于稳定。

3.VM栈，本地方法栈，PC计数器：这三个放到一起的原因是，只要新建一个线程，线程内部就会新建出这三块区域，所以线程建多了也会OOM。VM栈是整个程序运行核心，它的基本单位是栈帧，每个栈帧中包含着局部变量表（存放局部变量与引用等等），操作栈（具体执行数值操作等），动态连接（java运行时多态的关键，直到运行时才会根据实际类型去确定连接方法版本），返回地址。每当一个方法调用了另一个方法，程序进入时会将上一个方法的栈帧压人VM栈，然后新建一个栈帧，初始化为该方法，包括比如有变量传进来就在局部变量表中复制一份记录（java是值传递）等等。而PC计数器则是用来指示当前执行的语句行数，包括做跳转等等操作。至于本地方法栈顾名思义就是调用native方法时候会采用的。

这部分内存不由垃圾回收器管理，里面的内容随着该线程结束而消亡。

有空更新下半部分，类与类对象以及垃圾回收，还有OOM相关的部分
